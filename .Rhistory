return (
ifelse(x<deciles[1], 1,
ifelse(x<deciles[2], 2,
ifelse(x<deciles[3], 3,
ifelse(x<deciles[4], 4,
ifelse(x<deciles[5], 5,
ifelse(x<deciles[6], 6,
ifelse(x<deciles[7], 7,
ifelse(x<deciles[8], 8,
ifelse(x<deciles[9], 9, 10
))))))))))
}
ROTable <- function(df, target, probability)
{
tmp <- df[, c(target,probability)]
colnames(tmp)[1] = "Target"
colnames(tmp)[2] = "prob"
tmp$deciles<-decile(tmp$prob)
mydata.DT = data.table(tmp) ## Converting the data frame to data table object
## Creating Aggregation and Group By similar to as in SQL
Target_Rate = sum(mydata.DT$Target)/nrow(mydata.DT)
rank <- mydata.DT[, list(
min_prob = round(min(prob),3),
max_prob = round(max(prob),3),
cnt = length(Target),
cnt_resp = sum(Target),
cnt_non_resp = sum(Target == 0)
) ,
by = deciles][order(-deciles)]
rank$RRate <- rank$cnt_resp / rank$cnt ## computing response rate
rank$cum_tot <- cumsum(rank$cnt) ## computing cum total customers
rank$cum_resp <- cumsum(rank$cnt_resp) ## computing cum responders
rank$cum_non_resp <-
cumsum(rank$cnt_non_resp) ## computing cum non-responders
rank$cum_RRate = rank$cum_resp / rank$cum_tot
rank$cum_rel_resp <- rank$cum_resp / sum(rank$cnt_resp)
rank$cum_rel_non_resp <- rank$cum_non_resp / sum(rank$cnt_non_resp)
rank$ks <- rank$cum_rel_resp - rank$cum_rel_non_resp
rank$lift <- round(rank$cum_RRate / Target_Rate,1)
rank$RRate<-percent( rank$RRate)
rank$cum_RRate<-percent( rank$cum_RRate)
rank$cum_rel_resp<-percent(rank$cum_rel_resp)
rank$cum_rel_non_resp<-percent(rank$cum_rel_non_resp)
rank$ks <- percent( rank$ks)
## KS
rank ## display Rank Ordering Table
}
names(op)[names(op)==input$Target]="Target"
rot<- ROTable(op,"Target","prob")
rot
})
rankorderrv<-eventReactive(input$Rankordv, {
kp<- rnkorderv()
kp<-data.frame(kp)
colnames(kp)<-c("Deciles","Min.prob","Max.prob","cnt","cnt.Resp","cnt.Non.Resp","RRate","cum.Tot","cum.Resp",
"cum.Non.Resp","cum.RRate","cum.Per.Resp", "cum.Per.Non.Resp","KS","Lift")
kp
})
output$Rankorderingv<-DT::renderDataTable(
rankorderrv(),rownames= FALSE
,    options = list(
lengthChange = FALSE,
initComplete = JS(
"function(settings, json) {",
"$(this.api().table().header()).css({'background-color': '#42f', 'color': '#fff'});",
"}"),
autowidth = "100%",
columnDefs = list(list(width = '70%', targets = 1))
))
concordancebd<-eventReactive(input$Comprconc, {
concotable()
})
output$concordanced<-renderTable({
concordancebd()
},bordered =T,caption = "Concordance (Development)",
caption.placement = getOption("xtable.caption.placement", "top"),
caption.width = getOption("xtable.caption.width", NULL))
concotablev<-reactive({
op <- data.frame(get((input$val)))
mylogit1<-mylogit()
op$prob<-predict.glm(mylogit1,op,type="response")
concordance <- function(df, target, probability)
{
tmp <- df[, c(target, probability)]
colnames(tmp)[1] = "Target"
colnames(tmp)[2] = "prob"
concordance1 = function(y, yhat)
{
Con_Dis_Data = cbind(y, yhat)
ones = Con_Dis_Data[Con_Dis_Data[, 1] == 1, ]
zeros = Con_Dis_Data[Con_Dis_Data[, 1] == 0, ]
conc = matrix(0, dim(zeros)[1], dim(ones)[1])
disc = matrix(0, dim(zeros)[1], dim(ones)[1])
ties = matrix(0, dim(zeros)[1], dim(ones)[1])
for (j in 1:dim(zeros)[1])
{
for (i in 1:dim(ones)[1])
{
if (ones[i, 2] > zeros[j, 2])
{
conc[j, i] = 1
}
else if (ones[i, 2] < zeros[j, 2])
{
disc[j, i] = 1
}
else if (ones[i, 2] == zeros[j, 2])
{
ties[j, i] = 1
}
}
}
Pairs = dim(zeros)[1] * dim(ones)[1]
PercentConcordance = (sum(conc) / Pairs) * 100
PercentDiscordance = (sum(disc) / Pairs) * 100
PercentTied = (sum(ties) / Pairs) * 100
return(
list(
"Percent Concordance" = PercentConcordance,
"Percent Discordance" = PercentDiscordance,
"Percent Tied" = PercentTied,
"Pairs" = Pairs
)
)
}
concordance_output <- concordance1(tmp$Target, tmp$prob)
concordance_output
}
names(op)[names(op)==input$Target]="Target"
concordance(op,"Target","prob")
})
concordancebv<-eventReactive(input$Comprconc, {
concotablev()
})
output$concordancev<-renderTable({
concordancebv()
},bordered =T,caption = "Concordance (Validation)",
caption.placement = getOption("xtable.caption.placement", "top"),
caption.width = getOption("xtable.caption.width", NULL))
statT1<-eventReactive(input$Compr, {
op <- data.frame(get((input$dev)))
mylogit1<-mylogit()
op$prob<-predict.glm(mylogit1,op,type="response")
rtdev<- rnkorder()
td<-data.frame(statistics="3rd Decile Capture",value=rtdev[3,12])
lt<-data.frame(statistics="1st lift",value=rtdev[1,15])
colnames(td)<-c("statistics","value")
colnames(lt)<-c("statistics","value")
names(op)[names(op)==input$Target]="Target"
library(ineq)
gini=ineq(op$prob,type = "Gini")
library(ROCR)
pred=prediction(op$prob,op$Target)
perf=performance(pred,"tpr","fpr")
ks=max(attr(perf,'y.values')[[1]]-attr(perf,'x.values')[[1]])
ks
auc=performance(pred,"auc")
auc=as.numeric(auc@y.values)
auc
mp<-data.frame(statistics="GINI",value=gini*100)
pp<-data.frame(statistics="AUC",value=auc*100)
kp<-data.frame(statistics="KS",value=ks*100)
decile <- function(x){
deciles <- vector(length=10)
for (i in seq(0.1,1,.1)){
deciles[i*10] <- quantile(x, i, na.rm=T)
}
return (
ifelse(x<deciles[1], 1,
ifelse(x<deciles[2], 2,
ifelse(x<deciles[3], 3,
ifelse(x<deciles[4], 4,
ifelse(x<deciles[5], 5,
ifelse(x<deciles[6], 6,
ifelse(x<deciles[7], 7,
ifelse(x<deciles[8], 8,
ifelse(x<deciles[9], 9, 10
))))))))))
}
hosmerlem_gof <- function(df, target, probability,g=10)
{
tmp <- df[, c(target, probability)]
colnames(tmp)[1] = "Target"
colnames(tmp)[2] = "prob"
tmp$deciles<-decile(tmp$prob)
hosmerlem <-
function (y, yhat, g1=g) {
cutyhat <-
cut(yhat,
breaks = quantile(yhat, probs = seq(0, 1, 1 / g1)),
include.lowest = T)
obs <-xtabs(cbind(1 - y, y) ~ cutyhat)
expect <-xtabs(cbind(1 - yhat, yhat) ~ cutyhat)
chisq <-sum((obs - expect) ^ 2 / expect)
P <-1 - pchisq(chisq, g1 - 2)
c("X^2" = chisq,Df = g1 - 2,"P(>Chi)" = P)
}
hl_gof <- hosmerlem(tmp$Target, tmp$prob)
# print(hl_gof)
# print("Table")
# sqldf ("select deciles, count(1) as cnt,
#        sum (Target) as Obs_Resp, count (Target == 0) as Obs_Non_Resp,
#        sum (prob) as Exp_Resp, sum (1 - prob) as Exp_Non_Resp
#        from tmp
#        group by deciles
#        order by deciles desc")
hl_gof
}
names(op)[names(op)==input$Target]="Target"
oo<-data.table(t(hosmerlem_gof(op,"Target","prob")))
ch<-data.frame(statistics="X^2", value=oo$`X^2`)
ch1<-data.frame(statistics="X^2 P(>Chi)", value=oo$`P(>Chi)`)
df<-rbind(kp,pp,mp,ch,ch1)
df$value<-round(df$value,3)
df<-rbind(df,td,lt)
df
})
statT2<-eventReactive(input$Compr, {
op <- data.frame(get((input$val)))
mylogit1<-mylogit()
op$prob<-predict.glm(mylogit1,op,type="response")
rtval<-rnkorderv()
td<-data.frame(statistics="3rd Decile Capture",value=rtval[3,12])
lt<-data.frame(statistics="1st lift",value=rtval[1,15])
colnames(td)<-c("statistics","value")
colnames(lt)<-c("statistics","value")
names(op)[names(op)==input$Target]="Target"
library(ineq)
gini=ineq(op$prob,type = "Gini")
library(ROCR)
pred=prediction(op$prob,op$Target)
perf=performance(pred,"tpr","fpr")
ks=max(attr(perf,'y.values')[[1]]-attr(perf,'x.values')[[1]])
ks
auc=performance(pred,"auc")
auc=as.numeric(auc@y.values)
auc
mp<-data.frame(statistics="GINI",value=gini*100)
pp<-data.frame(statistics="AUC",value=auc*100)
kp<-data.frame(statistics="KS",value=ks*100)
decile <- function(x){
deciles <- vector(length=10)
for (i in seq(0.1,1,.1)){
deciles[i*10] <- quantile(x, i, na.rm=T)
}
return (
ifelse(x<deciles[1], 1,
ifelse(x<deciles[2], 2,
ifelse(x<deciles[3], 3,
ifelse(x<deciles[4], 4,
ifelse(x<deciles[5], 5,
ifelse(x<deciles[6], 6,
ifelse(x<deciles[7], 7,
ifelse(x<deciles[8], 8,
ifelse(x<deciles[9], 9, 10
))))))))))
}
hosmerlem_gof <- function(df, target, probability,g=10)
{
tmp <- df[, c(target, probability)]
colnames(tmp)[1] = "Target"
colnames(tmp)[2] = "prob"
tmp$deciles<-decile(tmp$prob)
hosmerlem <-
function (y, yhat, g1=g) {
cutyhat <-
cut(yhat,
breaks = quantile(yhat, probs = seq(0, 1, 1 / g1)),
include.lowest = T)
obs <-xtabs(cbind(1 - y, y) ~ cutyhat)
expect <-xtabs(cbind(1 - yhat, yhat) ~ cutyhat)
chisq <-sum((obs - expect) ^ 2 / expect)
P <-1 - pchisq(chisq, g1 - 2)
c("X^2" = chisq,Df = g1 - 2,"P(>Chi)" = P)
}
hl_gof <- hosmerlem(tmp$Target, tmp$prob)
# print(hl_gof)
# print("Table")
# sqldf ("select deciles, count(1) as cnt,
#        sum (Target) as Obs_Resp, count (Target == 0) as Obs_Non_Resp,
#        sum (prob) as Exp_Resp, sum (1 - prob) as Exp_Non_Resp
#        from tmp
#        group by deciles
#        order by deciles desc")
hl_gof
}
names(op)[names(op)==input$Target]="Target"
oo<-data.table(t(hosmerlem_gof(op,"Target","prob")))
ch<-data.frame(statistics="X^2", value=oo$`X^2`)
ch1<-data.frame(statistics="X^2 P(>Chi)", value=oo$`P(>Chi)`)
df<-rbind(kp,pp,mp,ch,ch1)
df$value<-round(df$value,3)
df<-rbind(df,td,lt)
df
})
merg<-eventReactive(input$Compr, {
tb1<-statT1()
tb2<-statT2()
tb3<-merge(tb1,tb2,by="statistics")
colnames(tb3)<-c("Statistics","Development","Validation")
tb3<-tb3[c(5,2,1,4,6,7,3),]
tb3
})
output$stat2<-renderTable({
merg()
},bordered =T,
caption = "Model Statistics",
caption.placement = getOption("xtable.caption.placement", "top"),
caption.width = getOption("xtable.caption.width", NULL))
output$stat3<-renderTable({
statT2()
},bordered =T,
caption = "Model Statistics",
caption.placement = getOption("xtable.caption.placement", "top"),
caption.width = getOption("xtable.caption.width", NULL))
output$savelist<-
renderUI({
checkboxGroupInput(
label = "Select Objects to Save" ,
choices = list("Development Data","Validation Data","Model","Rank Ordering Table(Development)",
"Rank Ordering Table(Validation)","Comparision Table","Information Value Table",
"Single Variable glm Table"),
selected = NULL,
inputId = "savelist"
)
})
information_value<-reactiveValues()
p_value<-reactiveValues()
Plot_data_varclus<-reactiveValues()
glmmodel <- reactiveValues()
vif_table<-reactiveValues()
rank_order_development<-reactiveValues()
model_stat<-reactiveValues()
chi_sq<-reactiveValues()
chi_sq_calculation<-reactiveValues()
concordance_dev<-reactiveValues()
beta_ratio_table<-reactiveValues()
rank_order_validation<-reactiveValues()
comparison_table<-reactiveValues()
concordance_val<-reactiveValues()
observe({
if(is.null(ntextivv()))
isolate(
information_value <<- NULL
)
if(!is.null(ntextivv()))
isolate(
information_value <<- ntextivv()
)
})
observe({
if(is.null(ntextp()))
isolate(
p_value <<- NULL
)
if(!is.null(ntextp()))
isolate(
p_value <<- ntextp()
)
})
observe({
if(is.null(ntextpx()))
isolate(
Plot_data_varclus <<- NULL
)
if(!is.null(ntextpx()))
isolate(
Plot_data_varclus <<- ntextpx()
)
})
observe({
if(is.null(mylogit()))
isolate(
glmmodel <<- NULL
)
if(!is.null(mylogit()))
isolate(
glmmodel <<- mylogit()
)
})
observe({
if(is.null(VIFC()))
isolate(
vif_table <<- NULL
)
if(!is.null(VIFC()))
isolate(
vif_table <<- VIFC()
)
})
observe({
if(is.null(rankorderr()))
isolate(
rank_order_development <<-NULL
)
if(!is.null(rankorderr()))
isolate(
rank_order_development <<- rankorderr()
)
})
observe({
if(is.null(statT()))
isolate(
model_stat <<- NULL
)
if(!is.null(statT()))
isolate(
model_stat <<- statT()
)
})
observe({
if(is.null(chi1b()))
isolate(
chi_sq <<- NULL
)
if(!is.null(chi1b()))
isolate(
chi_sq <<- statT()
)
})
observe({
if(is.null(chi2b()))
isolate(
chi_sq_calculation <<- NULL
)
if(!is.null(chi2b()))
isolate(
chi_sq_calculation <<- chi2b()
)
})
observe({
if(is.null(concordanceb()))
isolate(
concordance_dev <<- NULL
)
if(!is.null(concordanceb()))
isolate(
concordance_dev <<- concordanceb()
)
})
observe({
if(is.null(betacal()))
isolate(
beta_ratio_table <<- NULL
)
if(!is.null(betacal()))
isolate(
beta_ratio_table <<- betacal()
)
})
observe({
if(is.null(rankorderrv()))
isolate(
rank_order_validation <<- NULL
)
if(!is.null(rankorderrv()))
isolate(
rank_order_validation <<- rankorderrv()
)
})
observe({
if(is.null(merg()))
isolate(
comparison_table <<- NULL
)
if(!is.null(merg()))
isolate(
comparison_table <<- merg()
)
})
observe({
if(is.null(concordancebv()))
isolate(
concordance_val <<-NULL
)
if(!is.null(concordancebv()))
isolate(
concordance_val <<- concordancebv()
)
})
docummnt1<-reactive({
pp<-input$documentation
pp
})
observe({
if(is.null(docummnt1()))
isolate(
docummnt <<- NULL
)
if(!is.null(docummnt1()))
isolate(
docummnt <<- docummnt1()
)
})
output$downloadData <- downloadHandler(
filename <- function(){
paste("All.RData")
},
content = function(file) {
save( information_value,p_value,Plot_data_varclus,glmmodel , vif_table,
rank_order_development, model_stat,chi_sq,chi_sq_calculation, concordance_dev,beta_ratio_table,
rank_order_validation, comparison_table,concordance_val, file = file)
write.table(docummnt,file="documentation.txt")
}
)
}
}
shinyApp(ui, server)
}}
logisticmodelcreation(m)
library(logisticmodelcretaion)
logisticmodelcreation(m)
